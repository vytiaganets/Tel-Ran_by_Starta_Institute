// 1. В чем разница между let, const и var?

// -var был первым способом объявления переменных в JavaScript. Он имеет функциональную область видимости (function scope), что означает, что переменные могут быть видны внутри функции, но не за её пределами. Его можно переопределить и объявить повторно в рамках одной области видимости.
// -let и const появились в ECMAScript 6 (ES6). let имеет блочную область видимости (block scope), что означает, что переменная видна только в блоке кода, в котором она определена (скобки {}). Она также не поднимается (hoisted) в начало блока. const также имеет блочную область видимости и предназначен для объявления переменных, значения которых не могут быть изменены после их присвоения. Попытка переопределить const приведет к ошибке.

// Пример с var
var x = 10;
if (true) {
  var x = 20;
  console.log(x); // Выведет 20
}
console.log(x); // Выведет 20, переменная была переопределена

// Пример с let
let y = 10;
if (true) {
  let y = 20;
  console.log(y); // Выведет 20
}
console.log(y); // Выведет 10, переменная внутри блока не затрагивает глобальную

const a = 5;
a = 4; //ошибка


// 2. В чем разница между function declaration, function expression и arrow function?


// -function declaration - это стандартный способ объявления функций. Он определяет функцию и поднимает ее (hoisting) в начало текущей области видимости.
// -function expression - это объявление функции в контексте выражения. Она не поднимается в начало блока и доступна только после инициализации.
// -arrow function - это синтаксически более краткий способ определения функции. Они не имеют собственного this, arguments, super, или new.target. Они также не могут быть использованы как конструкторы.

// Function Declaration
function greet() {
    console.log("Hello!");
}
  
  // Function Expression
const greet = function() {
    console.log("Hello!");
};
  
  // Arrow Function
const greet = () => {
    console.log("Hello!");
};

// 3. Что такое замыкания?

// Замыкания (Closures) - это особенность JavaScript, когда функция запоминает окружающую область видимости, в которой она была создана. Это позволяет функции обращаться к переменным внешней функции, даже если она вызывается за пределами этой области видимости.

function outer() {
    const name = "John";
    function inner() {
      console.log(name);
    }
    return inner;
  }
  
const innerFunc = outer();
innerFunc(); // Выведет "John", innerFunc запомнила переменную name из outer()


// 4. Что такое callback-функция?

// Callback-функция - это функция, передаваемая в качестве аргумента другой функции и вызываемая этой функцией в определенный момент времени или при наступлении определенного события. Они часто используются в асинхронном программировании или для выполнения кода после завершения определенной операции.

function fetchData(callback) {
    // Представим, что это асинхронный запрос данных
    setTimeout(() => {
      const data = "Это данные";
      callback(data);
    }, 1000);
}
  
function displayData(data) {
    console.log(data);
}
  
fetchData(displayData); // Вызов fetchData с callback-функцией


// 5. Какие вы знаете методы массивов? Расскажите, как работают эти методы

// Методы массивов - это функции, которые применяются к массивам для выполнения различных операций над их элементами. Некоторые из них:

// push() - Добавляет один или несколько элементов в конец массива и возвращает новую длину массива.
// pop() - Удаляет последний элемент массива и возвращает его значение.
// unshift() - Добавляет один или несколько элементов в начало массива и возвращает новую длину массива.
// shift() - Удаляет первый элемент массива и возвращает его значение.
// map() - создает новый массив, применяя функцию к каждому элементу исходного массива.
// filter() - создает новый массив, содержащий элементы, для которых функция возвращает true.
// reduce() - применяет функцию к аккумулятору и каждому значению массива для вычисления единственного результата.
// forEach() - выполняет функцию для каждого элемента